<a name="nav"></a>

_nav_
|_<b>[Верстка](#верстка)</b>_
|_<b>[Стили, визуал, дизайн](#дизайн)</b>_
|_<b>[Замеченные особенности nocode tools](#nocode)</b>_
<a name="верстка"></a>
 # Верстка

1. [Семантика](#1)
2. [Теги](#2)
3. [Подключаемые файлы](#3)

<a name="1"></a>

## Семантика

<a name="1.1"></a>

- [1.1](#1.1) Объединять блоки не по их визуальному расположению, а по их смыслу.

  Объединяем блоки вот так:  
  ![хороший пример](http://image.prntscr.com/image/665a3fda6b3847e687c4ed5fdbbaec22.png)

  А не вот так:  
  ![плохой пример](http://image.prntscr.com/image/ea6179004eb9493e90a4ceae4dad2a7c.png).  
  Как минимум, это очень легко позволит потом добавить новый элемент, когда надо будет по требованию заказчика сделать лист из 4 элементов, а не трех, как здесь. Плюс второй подход очень неудобен, если контент генерируется динамически. Так что если вы создаете верстку, которую потом будут прикручивать к бэкенду заказчики, и сделаете такую верстку, проклятия от их программистов и порча всей нашей кармы обеспечены.

<a name="1.2"></a>

- [1.2](#1.2) Если есть что-то похожее на список, проверяем, как будет выглядеть при большем количестве элементов.

  ![список](https://rizzoma.com/r/files/a87a0a28b84d6326d4f3909e8801dab7-97a135d68ad6e2e449e9c9f2dbf9766c-0-0.6276249218551724)

  Если непонятно, что будет при 4-х элементах, как в этом случае, обязательно спросить, а не принимать решение самостоятельно

<a name="1.3"></a>

- [1.3](#1.3) Все элементы с текстом, контент которых формируется динамически, проверяем на то, чтобы они не ломались при большем количестве текста, чем на макете.

  В имена подставляем знаменитое [Константин Константинопольский](https://tema.livejournal.com/1322108.html).  
  В идеале моменты, которые будет трудно масштабировать текстом, находить еще на стадии знакомства с макетом и задавать вопросы дизайнеру.

<a name="1.4"></a>

- [1.4](#1.4) Все изображения должны содеражать alt атрибут [вот почему](https://habr.com/ru/post/341810/) 

<a name="1.5"></a>

- [1.5](#1.5) Использовать h1..h6 только для заголовков, причем h1 должен встречаться в одной странице всего один раз. Содержание заголовка должно полноценно описывать раздел. Важно для SEO.

<a name="2"></a>

## Теги

<a name="2.1"></a>

- [2.1](#2.1) Все теги должны работать даже без CSS и JS.

  Все тексты, видимые сначала при открытии страницы так же должны быть доступны, формы должны сабмититься, ссылки должны переходить (а ссылки, по которым вообще не должно быть перехода и для которых принято ставить `href="#"`, вообще не использовать, это будет далее [2.5](#2.5) ).

<a name="2.2"></a>

- [2.2](#2.2) Структура тегов в первую очередь должна идти от содержания, а не от дизайна

  ![пример](http://image.prntscr.com/image/a89c1aed00f14864851989caceacd59d.png) — например, такой элемент можно оформить как четыре идущих подряд элемента: иконка сообщений, бадж с цифрой 10, иконка аватара и имя пользователя. Но тут надо явно объединить с помощью `<div>` два блока, чтобы семантически они были отдельными — блок с информацией по сообщению и блок про пользователя. Для css потом, возможно, придется писать лишние стили, но верстка будет более осмысленной и не привязанной лишний раз к дизайну.

<a name="2.3"></a>

- [2.3](#2.3) У каждой страницы должны быть прописан `title` и мета теги `keywords`, `description` (на содержимое спросить контент у менеджера).


<a name="2.4"></a>

- [2.4](#2.4) Если в проекте нет других соглашений, атрибуты должны именоваться lower-case-hyphenated (имена только маленькими буквами и через дефис) и, если значение строковое и показывает какое-то имя, то тоже должно быть lower-case-hyphenated. Кастомные атрибуты стараться начинать с data- (это стандартная практика, рекомендованная для HTML5).


<a name="2.5"></a>

- [2.5](#2.5) Не использовать ссылки с пустым или невалидным `href` (никаких `<a href="#">`) — тогда лучше использовать ссылку-заглушку на несуществующий урл, который явно говорит, что ссылка не проставлена.

<a name="2.6"></a>

- [2.6](#2.6) Ссылки на чужие сайты должны открываться в новом окне.

<a name="2.7"></a>

- [2.7](#2.7) Все ссылки, открывающиеся в новом окне, должны быть Mark the links as nofollow.

  Это связано с [уязвимостью](https://mathiasbynens.github.io/rel-noopener/), в соответствии с которой сайт, который вы открыли, получит доступ к сайту, с которого перешли через `window.opener`, причем это работает даже кроссдоменно.

<a name="2.8"></a>

- [2.8](#2.8) Спрашивать у дизайнеров, какие элементы делать autofocus на какой странице.

<a name="2.9"></a>

- [2.9](#2.9) Если у поля есть четкое назначение, то использовать соответствующий тип (email, number и т. д.).

<a name="2.10"></a>

- [2.10](#2.10) Каждый элемент, в котором может лежать текст, должен быть проверен на большое количество символов.

  Все заголовки и все теги с текстовыми описаниями.  
  Все инпуты проверять, чтобы при заполнении текст не прижимался вплотную к правой границе:  
  ![image](https://user-images.githubusercontent.com/12808495/55307777-c0e18e80-5482-11e9-927f-9c195d81555e.png)


<a name="3"></a>

## Подключаемые файлы

<a name="3.1"></a>

- [3.1](#3.1) Все картинки, шрифты и т. д. должны иметь уникальное название в рамках проекта и не содержать кириллических символов. Если в проекте нет индивидуальных соглашений, то они должны именоваться в стиле lower-case-hyphenated.

<a name="3.2"></a>

- [3.2](#3.2) В проекте обязательно должен быть favicon.ico, подключаемый на всех страницах.

<a name="3.3"></a>

- [3.3](#3.3) В сафари своя версия favicon, ее тоже обязательно надо настраивать.

  То есть нужна svg для контура иконки, и нужен цвет для иконки при наведении. [Статья](https://yoast.com/dev-blog/safari-pinned-tab-icon-mask-icon/).

<a name="3.4"></a>

- [3.4](#3.4) Прогонять картинки через [kraken.io](https://kraken.io/) или использовать свои CLI-утилиты для этого.

<a name="3.5"></a>

- [3.5](#3.5) Все фотографии и картинки, где нет прозрачности, делать в jpg.

<a name="3.6"></a>

- [3.6](#3.6) При нарезке картинок из фотошопа поставить DPI равным 72dpi, а саму картинку сохранить через "Save for Web".

<a name="3.7"></a>

- [3.7](#3.7) Максимальная ширина картинки — 1920 пикселей. Если в макетах она больше, пропорционально ужимайте.

  На самом деле, это правило спорно (как минимум для ретина дисплеев я не уверен), но следуйте ему, пока дизайнер не скажет другого.

<a name="дизайн"></a>
# Стили, визуал, дизайн
_[to nav](#nav)_
1. [Общие требования](#4)
2. [Правила](#5)
3. [Шрифты](#6)
4. [БЭМ](#7)

<a name="4"></a>

## Общие требования

<a name="1.1"></a>

- [1.1](#1.1) Главное! Используем [pixel-perfect](https://chrome.google.com/webstore/detail/perfectpixel-by-welldonec/dkaagdgjmgdmbnecmcefdhjekcoceebi?hl=ru), если заказчик предоставил макет.

<a name="1.2"></a>

- [1.2](#1.2) Для подключения кастомных стилей, шрифтов, css-анимаций - использовать сервер сервиса которым пользуетесь([пример подключения кастомного шрифта в bubbleio](https://manual.bubble.io/help-guides/building-a-user-interface/using-custom-fonts#installing-a-custom-font)) 

<a name="1.3"></a>

- [1.3](#1.3) Человекочитаемые деревья. 
    Дерево элементов страницы должно читаться и быть семантически понятным. Избегать именования элементов типа Image A, Group HZ, MaterialIcon Arrow и т.д.  <b><i>В РАЗРАБОТКЕ</b></i> Рекомендуется именовать элементы по `БЭМ` (прочитать про него обязательно хотя бы в общих чертах) или, например, [rscss](https://rscss.io/index.html). Для начала можете изучить [небольшой подход](https://isobar-us.github.io/code-standards/), который используют ребята из `Isobar` — он описан в рамках их стандарта и состоит из 7 небольших абзацев.

<a name="1.4"></a>

- [1.4](#1.4) Если какой либо блок используется более 2ух раз одновременно, нужно превратить его в reuseable element. Это крайне ускоряет внесение любых изменения в проект, а так же облегчает его поддержку и визуально разгружает workflow и element tree.

<a name="1.5"></a>

- [1.5](#1.5) Использовать пресеты стилей для кнопок, иконок, блоков, ссылок. Также у многих платформ есть кастомный color palete. В него можно заранее выгрузить цвета используемые в проекте и далее при создании стилей это даст ускорение)

<a name="1.6"></a>

- [1.6](#1.6) Для всех интерактивных элементов (ссылки, кнопки, дропдауны, инпуты, селекты) дизайнер может прорисовать отдельные состояния и спрятать в ближайшем слое — всегда проверять для каждого элемента, есть ли отрисованное состояние.

<a name="1.7"></a>

- [1.7](#1.7) Дизайнеры могут ошибаться — иногда надо делать запросы на изменение макета, если они нарисовали что-то переусложненное.

  Например, в макете может быть отцентрированная по вертикали относительно текста полоска:

  | ![Пример](https://user-images.githubusercontent.com/12808495/55335190-df687980-54c4-11e9-8623-13ecdb996ebc.png) |
  | :-------------------------------------------------------------------------------------------------------------: |
  |                       _эта картинка просто пример, не факт, что тут как раз такая ошибка_                       |

  Дизайнер может просто на глаз положить эту полоску на среднем уровне нижних букв текста, однако вы как верстальщики просто примените vertical-align: middle и увидите, что полоска выше/ниже уровня, который показал дизайн, и Pixel Perfect явно это подсвечивает. Чаще всего не надо хардкодить какой-нибудь неочевидный отступ, просто чтобы идеально соответствовать макету — лучше сказать дизайнеру, что автоматом полоска ставится на другое место и её лучше там и оставить. А дизайнеру подучить типографику.

<a name="1.8"></a>

- [1.8](#1.8) Пытаться по максимуму делать сайт резиновым (ставьте ширину в процентах и выставляйте max-width, min-width) — прибегайте к фиксированной ширине элемента, только если по макету от этого никак не уйти.

  Если все-таки сайт должен быть с фиксированный шириной, обязательно проверяйте правую сторону каждой страницы на маленьких экранах. Очень частая ошибка новичков не все элементы делать с min-width, и при горизонтально прокрутке получается такая штука:

  ![image](https://rizzoma.com/r/files/a87a0a28b84d6326d4f3909e8801dab7-60dd9b15a5f2c5e495726e74545edcae-0-0.7016728184648524)

<a name="1.9"></a>

- [1.9](#1.9) Футер страницы должен быть всегда прижат к низу страницы, даже если на странице мало контента.

<a name="1.10"></a>

- [1.10](#1.10) Имена.

  Использовать `lower-case-hyphenated` (то есть НЕ `mySuperAwesomeElement` и НЕ `my_super_awesome_element`)

  Имена должны отражать смысл, а не описание стилей (`"loading"`, а не `"big-yellow-spinny-thing"`)

<a name="5"></a>

## Правила

<a name="2.1"></a>

- [2.1](#2.1) Не использовать отрицательные margin.

  Это очень неочевидно, их тяжело обнаружить, и их почти всегда можно заменить более легкими и предсказуемыми свойствами.

<a name="2.2"></a>

- [2.2](#2.2) Избегать фиксированных выравниваний.

  Если блок должен быть отцентрирован (хоть по горизонтали, хоть по вертикали), то центрировать его динамически, а не фиксированным `margin-top`.

<a name="2.3"></a>

- [2.3](#2.3) Удалять все неиспользуемые элементы, плагины, workflow. Для этого есть встроенные помощники(howto in bubbleio: settings-> general-> App file management-> Optimize application)  

<a name="2.4"></a>

- [2.4](#2.4) Обязательно прописать изменения стиля при фокусе для инпутов/кнопок condition when this input/button is focused

<a name="6"></a>

## Шрифты

<a name="3.1"></a>

- [3.1](#3.1) Если клиент предоставил макеты с кастомными шрифтами, проверить, свободные ли они и, если нет, то запросить купленные файлы шрифтов.

<a name="3.2"></a>

- [3.2](#3.2) Если в проекте должна быть поддержка нелатинских символов (например, русских), проверьте, что в файле шрифта эти символы есть.


<a name="7"></a>

## БЭМ (полезно знать и применять)
<i>(пока оставлю этот раздел без изменений, но с комментами:) )</i>

<a name="4.1"></a>

- [4.1](#4.1) Именование БЭМ-сущностей должно следовать следующим ограничениям:

  Блок, элемент — всегда имя существительное (noun)

  Модификатор — должен удовлетворять свойствам [модификатора из английского языка](https://en.wikipedia.org/wiki/Grammatical_modifier). Всегда `adjective` или `adjectival phrase`.

  Таким образом, фразы на английском языке `"$BLOCK_NAME [is] $MODIFIER_NAME"`, `"$ELEMENT_NAME [is] $MODIFIER_NAME"` или `"$MODIFIER_NAME $BLOCK_NAME"`, `"$MODIFIER_NAME $ELEMENT_NAME"`, `"$ELEMENT_NAME WITH $MODIFIER_NAME $MODIFIER_KEY"` должны быть синтаксически корректными словосочетаниями.

  Примеры _корректных имён_:

  - `input_selected` — `selected input` — выделенный инпут или `input is selected` — инпут выделен
  - `header_size_large` — `header with large size` — заголовок с большим размером.

  Примеры _**НЕ**корректных имён_:

  - `form__`**_save_**`_small`, для элемента save (который, например, вешается на кнопку) — `small save` — маленький сохранить, `save small` — сохранить маленький. Правильно будет употребить noun вместо `verb` и переименовать элемент в **_`save-button;`_** `small save-button` — маленькая кнопка сохранения

  - `input_`**_focus_** — `input focus` — инпут сфокусировать или `input is focus` — инпут это фокус. Правильно будет употребить `adjective` вместо `noun/verb` и переименовать модификатор в `focused; input_`**_focused_** — `focused input` — сфокусированный инпут

  - `row_`**_error_** — `row error` — ошибка строки или `row is error` — строка это ошибка. Правильно будет употребить `adjectival phrase` вместо `noun` и переименовать модификатор в `with-error`. `row_`**_with_**`-error` — `row with error` — строка с ошибкой.

  Обоснование: мы сможем всегда однозначно и без лишних затрат энергии истолковать сущность элемента вёрстки и накладываемые на него свойства.

<a name="4.2"></a>

- [4.2](#4.2) Верстаем всегда по БЭМу, архитектура верстки должна быть компонентной.

  Каждый блок должен лежать в своей папке.<i>(в нашем случае, это reuseable elements)</i>

  Папки блоков нельзя вкладывать друг в друга.

<a name="4.3"></a>

- [4.3](#4.3) Каждый компонент — отдельный блок из методологии БЭМ.

<a name="4.4"></a>

- [4.4](#4.4) Каждый компонент должен иметь только явные зависимости, быть самодостаточным.

  Все зависимости делать явно, импортируя в начале компонента и вставляя в нужное место верстки.

  Самодостаточность говорит о том, что каждый компонент должен внутри себя содержать все необходимое — всю верстку, все стили и все js-скрипты.

  Ничего лишнего в компоненте быть не должно:

  - Не должно быть определения других блоков внутри этого блока
  - Не должно быть стилей, которые бы влияли на другие блоки любым способом
  - Не должно быть глобальных стилей (например, на все теги `span`)
  - Компонент не должен влиять на `DOM` другого компонента (менять верстку крайне запрещено)

<a name="4.5"></a>

- [4.5](#4.5) Кастомизировать компоненты только через модификаторы, никаких примесей.<i>(в нашем случае, это про conditions и манипуляции с полями внтури when condition is true. Далее все модификаторы можно приравнивать к condition у элементов)</i>

  Почти в любом проекте возникает необходимость кастомизировать блоки. Например, есть вёрстка из 20 страниц. На 15 из этих страниц встречается хэдер, причём у 10 из них хэдер синего цвета, на трёх — серый, и на двух — прозрачный. Это значит, что компонент хэдер должен быть кастомизируемым, и осуществляются подобного рода кастомизации через добавление модификаторов к блоку, а не путём передачи отдельных классов со стилями.

  Предположим, что на фоне у промо страницы есть видео, и по дизайну нам нужно сделать прозрачный хэдер со светлым шрифтом (по умолчанию — тёмный).

  Плохо:

  ```pug
  .promo-page
    +header({ classname: 'promo-page__header' })
  ```

  Хорошо:

  ```pug
  .promo-page
    +header({ theme: 'transparent', font: 'light' })
  ```

  При правильном подходе, естественно, надо будет научиться принимать эти два параметра, добавлять самому модификаторы к нужным классам и в CSS компонента прописывать правила для этих модификаторов.

  Это правило внедрено после болезненного опыта поддержки проекта средней сложности, и вот какие шишки набиты с использованием примесей:

  - Нарушается инкапсуляции — использование внешних стилей внутри компоненты ведёт к проблемам в сопровождении в дальнейшем. Дело в том, что стили компоненты являются её составной частью и не должны влиять на то, что её окружает. Также справедливо обратное — внешние стили не должны влиять на компоненту. Иными словами, компонента должна быть самодостаточна. Прибегая к использованию внешних стилей, мы создаём зависимость между двумя стилями — внешним и внутренним. Каждому из стилей нужно знать, из чего состоит другой, чтобы глобальный стиль не поломал стиль компоненты. Это и есть нарушение инкапсуляции

  - Если компонента используется на 20 разных страницах, то после изменения одного свойства в самом компоненте придется пройти по всем 20 страницам вручную и проверить, что ничего не сломалось, потому что неизвестно, какие могут быть стили навешаны в местах использования через кастомные классы, и надо самому проверить все комбинации

  - Примесь обычно вешается только на верхний уровень компонента, но иногда надо кастомизировать что-нибудь внутреннее, тогда получается, надо уже две примеси передавать и принимать в компоненте, одна примесь — для свойств всего блока, вторая — для какого-то элемента, а когда понадобится еще другой элемент кастомизировать, придется добавить третью примесь :)

  - Не получится четко составить список всех возможных состояний компоненты, а при подходе с модификаторами мы явно видим все возможные параметры на входе, и когда их число будет зашкаливать, можем пнуть дизайнера, что он слишком расфантазировался и пора бы переходить к единому стайлгайду

<a name="4.6"></a>

- [4.6](#4.6) Для позиционирования блока в родительском контейнере тоже не надо использовать миксы — решается данная проблема путем добавления специальных контейнеров.

  Допустим, есть родительский блок, в нем — дочерний блок, который нам и необходимо спозиционировать. Для позиционирования внутреннего блока создаем в родительском элемент-обертку и просто задаем свойства (_margin, padding, position_ etc) этому контейнеру. Таким образом, позиционирование блока у нас находится в файле родительского блока и никак не влияет на стили самого блока.

  Данный способ позволяет, не используя миксы, спозиционировать дочерний блок.

  Например, в хэдере у нас находится обычная голубая кнопка, но именно тут, в шапке, она должна иметь отступ с левой стороны, для этого мы добавим `div.header__button`:

  ```pug
   div.header
     div.header__button
       +button({ color:blue })
  ```

  А в стили хэдера просто добавим:

  ```css
  .header__button {
    margin-left: 3rem;
  }
  ```



<a name="nocode"></a>
# Замеченные особенности nocode tools
_[to nav](#nav)_
<a name="4.1"></a>

<b>- [4.1](#4.1) Bubble.io </b>

<a name="4.1.1"></a>

- [4.1.1](#4.1.1) Задать для каждой страницы в воркфлоу, обработчик события всех ошибок `An unhandled erros occurs` и добавить экшн со стилизацией алертов(стилизация на свой выбор)
<a name="4.1.2"></a>

- [4.1.2](#4.1.2) Открывание страницы в новой вкладке происходит через элемент link. Если в дизайне это кнопка, то стилизовать в  кнопку. Если картинка, то использовать background style - image и подгружать картинку(можно динамически)

<a name="4.1.3"></a>

- [4.1.3](#4.1.3) Использовать [fa] font-awesome-icon [/fa] в местах где необходимо наличие иконок и текста одновременно
